<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-9d3559ab-4e57-40d2-8357-2ee0e72b9f3f"></attachment><p><span style="color: rgb(102, 102, 102);">转自：</span></p><p><span style="color: rgb(102, 102, 102);">https://blog.csdn.net/jay100500/article/details/52955232</span></p><p><span style="color: rgb(102, 102, 102);">https://blog.csdn.net/andyhuabing/article/details/40983423</span></p><p><span style="color: rgb(102, 102, 102);">https://blog.csdn.net/liukun321/article/details/25337425</span></p><p><span style="color: rgb(102, 102, 102);">http://blog.chinaunix.net/uid-26084833-id-3416600.html</span></p><p>&nbsp;</p><p><span style="color: rgb(102, 102, 102);">AAC的音频文件格式有ADIF ＆ ADTS：</span></p><p>&nbsp;</p><p><strong style="color: rgb(102, 102, 102);">ADIF</strong><span style="color: rgb(102, 102, 102);">：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，</span></p><p><span style="color: rgb(102, 102, 102);">即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。</span></p><p>&nbsp;</p><p><strong style="color: rgb(102, 102, 102);">ADTS</strong><span style="color: rgb(102, 102, 102);">的全称是Audio Data Transport Stream。是AAC音频的传输流格式。</span></p><p><span style="color: rgb(102, 102, 102);">AAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。</span></p><p><span style="color: rgb(102, 102, 102);">这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。</span></p><p>&nbsp;</p><p><span style="color: rgb(102, 102, 102);">简单说，ADTS可以在任意帧解码，也就是说它每一帧都有头信息。ADIF只有一个统一的头，所以必须得到所有的数据后解码。</span></p><p><span style="color: rgb(102, 102, 102);">且这两种的header的格式也是不同的，目前一般编码后的和抽取出的都是ADTS格式的音频流。</span></p><p>&nbsp;</p><p>有的时候当你编码AAC裸流的时候，会遇到写出来的AAC文件并不能在PC和手机上播放，很大的可能就是AAC文件的每一帧里缺少了ADTS头信息文件的包装拼接。</p><p>只需要加入头文件ADTS即可。一个AAC原始数据块长度是可变的，对原始帧加上ADTS头进行ADTS的封装，就形成了ADTS帧。</p><p>&nbsp;</p><p><span style="color: rgb(102, 102, 102);">AAC音频文件的每一帧由ADTS Header和AAC Audio Data组成。结构体如下：</span></p><p><span style="color: rgb(102, 102, 102);"><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412163208402-708641835.png"></span></p><p>&nbsp;</p><p>&nbsp;</p><p>每一帧的ADTS的头文件都包含了音频的采样率，声道，帧长度等信息，这样解码器才能解析读取。</p><p>一般情况下ADTS的头信息都是7个字节，分为2部分：</p><p>adts_fixed_header();</p><p>adts_variable_header();</p><p>其一为固定头信息，紧接着是可变头信息。固定头信息中的数据每一帧都相同，而可变头信息则在帧与帧之间可变。</p><p><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412164540030-927582785.png"></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>syncword</strong> ：同步头 总是0xFFF, all bits must be 1，代表着一个ADTS帧的开始</p><p><strong>ID</strong>：MPEG标识符，0标识MPEG-4，1标识MPEG-2</p><p><strong>Layer</strong>：always: '00'</p><p><strong>protection_absent</strong>：表示是否误码校验。Warning, set to 1 if there is no CRC and 0 if there is CRC</p><p><strong>profile</strong>：表示使用哪个级别的AAC，如01 Low Complexity(LC)--- AAC LC。有些芯片只支持AAC LC 。</p><p><br></p><p> 在MPEG-2 AAC中定义了3种：</p><p><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412165527986-1255350672.png"></p><p>&nbsp;</p><p>profile的值等于 Audio Object Type的值减1</p><p>profile = MPEG-4 Audio Object Type - 1</p><p>&nbsp;<img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412165549142-534424424.png"></p><p>&nbsp;</p><p><strong>sampling_frequency_index</strong>：表示使用的采样率下标，通过这个下标在 Sampling Frequencies[ ]数组中查找得知采样率的值。</p><p><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412165910792-313087782.png"></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>channel_configuration</strong>: 表示声道数，比如2表示立体声双声道</p><p><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412170107030-585907795.png"></p><p>&nbsp;</p><p><br></p><p>0: Defined in AOT Specifc Config</p><p>1: 1 channel: front-center</p><p>2: 2 channels: front-left, front-right</p><p>3: 3 channels: front-center, front-left, front-right</p><p>4: 4 channels: front-center, front-left, front-right, back-center</p><p>5: 5 channels: front-center, front-left, front-right, back-left, back-right</p><p>6: 6 channels: front-center, front-left, front-right, back-left, back-right, LFE-channel</p><p>7: 8 channels: front-center, front-left, front-right, side-left, side-right, back-left, back-right, LFE-channel</p><p>8-15: Reserved</p><p>&nbsp;</p><p><strong>&nbsp;接下来看下adts_variable_header();</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412170250898-1155690092.png"></strong></p><p>&nbsp;</p><p><strong>&nbsp;frame_length</strong> : 一个ADTS帧的长度包括ADTS头和AAC原始流.</p><p>frame length, this value must include 7 or 9 bytes of header length:</p><p>aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame)</p><p>protection_absent=0时, header length=9bytes</p><p>protection_absent=1时, header length=7bytes</p><p><strong>adts_buffer_fullness</strong>：0x7FF 说明是码率可变的码流。</p><p>number_of_raw_data_blocks_in_frame：表示ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始帧。</p><p>所以说number_of_raw_data_blocks_in_frame == 0 表示说ADTS帧中有一个AAC数据块。</p><p>&nbsp;</p><p>下面是ADTS的AAC文件部分：</p><p>&nbsp;</p><p>&nbsp;</p><p><img src="https://images2018.cnblogs.com/blog/780575/201804/780575-20180412171108618-1150438152.png"></p><p>&nbsp;</p><p>&nbsp;</p><p>第一帧的帧头7个字节为：0xFF 0xF1 0x4C 0x40 0x20 0xFF 0xFC</p><p>&nbsp;分析各个关键数值：</p><p>111111111111</p><p>0</p><p>00</p><p>1</p><p>01</p><p>0011</p><p>0</p><p>001</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0000100000111(帧长度)</p><p>11111111111</p><p>00</p><p><strong>计算帧长度</strong>：将二进制 0000100000111 转换成十进制为263。观察第一帧的长度确实为263个字节。</p><p>计算方法:（帧长度为13位，使用unsigned int来存储帧长数值）</p><p>unsigned int getFrameLength(unsigned char* str)</p><p>{</p><p> if ( !str )</p><p> {</p><p> return 0;</p><p> }</p><p> unsigned int len = 0;</p><p> int f_bit = str[3];</p><p> int m_bit = str[4];</p><p> int b_bit = str[5];</p><p> len += (b_bit&gt;&gt;5);</p><p> len += (m_bit&lt;&lt;3);</p><p> len += ((f_bit&amp;3)&lt;&lt;11);</p><p> return len;</p><p>}</p><p>&nbsp;</p><p><br></p>