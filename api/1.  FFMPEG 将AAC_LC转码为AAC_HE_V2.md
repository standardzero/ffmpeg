AAC的音频文件格式有**ADIF ＆ ADTS**：

**ADIF**：`Audio Data Interchange Format` 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，
不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。从文件开始处获取
音频的解码信息，若是文件的开始出被破坏掉就无法解码。

**ADTS**的全称是`Audio Data Transport Stream`。是AAC音频的传输流格式。
AAC音频格式在**MPEG-2（ISO-13318-7 2003）**中有定义。AAC后来又被采用到**MPEG-4**标准中。
这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。

简单说，ADTS可以在任意帧解码，也就是说它每一帧都有头信息。ADIF只有一个统一的头，所以必须得到所有的数据后解码。
且这两种的header的格式也是不同的，目前一般编码后的和抽取出的都是ADTS格式的音频流。

**需求**：我们需要ADTS封装格式的AAC。
ffmpeg 自带的aac编码器，一个比较坑的地方是当aac的profile 设置为`aac_he_v2`时，它是不支持ADTS格式输出，只支持ADIF格式输出。

所以需要集成支持ADTS的第三方AAC库, 业内音质效果比较好的是 `libfdk-aac`。

使用libfdk-aac编码时需要额外主要如下几点：

* aac查找编码器需要用名字查找`encoder = avcodec_find_encoder_by_name("libfdk_aac");`, 因为ffmpeg的aac的ID只有一个，若是使用ID查找编码器，还是会调用到ffmpeg自动的aac编码器。

* `HE_AAC` 和 `HEv2_AAC` 编码时， 需要pcm数据的采样点是2048，ffmpeg解码后的pcm数据的采用点是1024，这就意味解码两帧后才能编码。

* 设置profile

```
/*
Profiles:
aac_low
  MPEG-4 AAC LC (default)
aac_he
  MPEG-4 HE-AAC (SBR)
aac_he_v2
  MPEG-4 HE-AAC v2 (SBR+PS)
aac_ld
  MPEG-4 AAC LD
aac_eld
  MPEG-4 AAC ELD
*/


```

如下是代码， 编译代码参考：[ ffmpeg GDB 调试技巧](https://github.com/standardzero/ffmpeg/blob/master/compile/4.%20ffmpeg%20GDB%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7.md)


**transcode_aac.h**

```
#ifndef _TRANSCODE_AAC_H
#define _TRANSCODE_AAC_H

#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libavutil/opt.h>
#include <libavutil/pixdesc.h>
#include <libswresample/swresample.h>


#define MAX_AUDIO_PER_ENCODER  (2)

#define TRANSCODE_SUCCESS      (0)
#define TRANSCODE_ERROR        (-1)

typedef struct _StreamContext {
    int stream_index;
    AVCodecContext *dec_ctx;
    AVCodecContext *enc_ctx;
    SwrContext     *swresample_context;
    AVFrame        *frame[2];
    int            cur_frame_index;
}StreamContext;


typedef struct _AudioEncoderInfo
{
    int status;
    int index;
    int profile;
    int channels;
    int sample_rate;
    int bite_rate;
}AudioEncoderParam;

typedef struct _TranscodeContext TranscodeContext;

typedef struct _TranscodeContext
{
    void *self;
    int index;
    AVFormatContext *ifmt_ctx;
    AVFormatContext *ofmt_ctx;
    StreamContext   stream_ctx[MAX_AUDIO_PER_ENCODER];
    AudioEncoderParam stAudioEncoderParam[MAX_AUDIO_PER_ENCODER];
    int (*set_params)(TranscodeContext *self, AudioEncoderParam *pstAudioEncoderInfo, int param_num); // 设置音频编码参数
    int (*open_decoder)(TranscodeContext *self, const char *input_filename);//从输入源获取解码器
    int (*open_encoder)(TranscodeContext *self, const char *output_filename);//设置编码器
    int (*transcode_aac)(TranscodeContext *self); //转码一帧
    int (*release)(TranscodeContext *self);//释放资源
}TranscodeContext;


/*
 *  接口调用说明：只支持aac-
 *  1. 调用初始接口
 *  2. 调用设置音频转码参数
 *  3. 从输入源获取解码器
 *  4. 设置编码器 
 *  5. 调用转码接口-这个接口只转码一帧
 *  6. 退出转码后，需要调用接口释放资源 
 */
int Transcode_Init(int index);
TranscodeContext * Transcode_GetTranscodeContextHandle(int index);

#endif

```

**transcode_aac.c**

```
#include "transcode_aac.h"

static int Transcode_SetParams(TranscodeContext *self, AudioEncoderParam *pstAudioEncoderInfo, int param_num);
static int Transcode_OpenInputFile(TranscodeContext *pstTranscodeContext, const char *filename);
static int Transcode_OpenOutputFile(TranscodeContext *pstTranscodeContext, const char *filename);
static int Transcode_TransAudio(TranscodeContext *pstTranscodeContext);
static int Transcode_Release(TranscodeContext *pstTranscodeContext);

static TranscodeContext s_arstTranscodeContext[2];

TranscodeContext * Transcode_GetTranscodeContextHandle(int index)
{
    return (TranscodeContext *)(&s_arstTranscodeContext[index]);
}

int Transcode_Init(int index)
{
    int i = 0;

    TranscodeContext *self = Transcode_GetTranscodeContextHandle(index);

    self->self = self;
    self->index = index;
    self->ifmt_ctx = NULL;
    self->ofmt_ctx = NULL;
    
    for(i = 0; i < MAX_AUDIO_PER_ENCODER; ++i)
    {
        self->stream_ctx[i].stream_index = -1;
        self->stream_ctx[i].dec_ctx = NULL;
        self->stream_ctx[i].enc_ctx = NULL;
        self->stream_ctx[i].swresample_context = NULL;
        self->stream_ctx[i].frame[0] = NULL;
        self->stream_ctx[i].frame[1] = NULL;
        self->stream_ctx[i].cur_frame_index  = 0;
    }

    for(i = 0; i < MAX_AUDIO_PER_ENCODER; ++i)
    {
        memset(&(self->stAudioEncoderParam[i]), 0, sizeof(AudioEncoderParam));
    }

    self->set_params = Transcode_SetParams;
    self->open_decoder = Transcode_OpenInputFile;
    self->open_encoder = Transcode_OpenOutputFile;
    self->transcode_aac = Transcode_TransAudio;
    self->release       = Transcode_Release;

    return TRANSCODE_SUCCESS;
}




```


